#!/usr/bin/env python3
"""
claude-monitor: Wrapper script to launch Claude Code with monitoring support.

Usage:
    claude-monitor start    Launch Claude Code in a tmux session

Note: tmux is required. Install with: brew install tmux
"""

import json
import os
import re
import shutil
import subprocess
import sys
import uuid
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional


def get_project_name(project_dir: Path) -> str:
    """Extract a reasonable project name from the directory path."""
    return project_dir.name


def slugify(name: str) -> str:
    """Convert a project name to a slug for tmux session names."""
    slug = name.lower()
    slug = re.sub(r"[\s_]+", "-", slug)
    slug = re.sub(r"[^a-z0-9-]", "", slug)
    slug = re.sub(r"-+", "-", slug)
    slug = slug.strip("-")
    return slug or "unnamed"


def is_tmux_available() -> bool:
    """Check if tmux is installed."""
    return shutil.which("tmux") is not None


def tmux_session_exists(session_name: str) -> bool:
    """Check if a tmux session exists."""
    result = subprocess.run(
        ["tmux", "has-session", "-t", session_name],
        capture_output=True,
    )
    return result.returncode == 0


def create_state_file(
    session_uuid: str,
    project_dir: Path,
    tmux_session: Optional[str] = None,
    session_type: str = "iterm",
) -> Path:
    """Create the .claude-monitor-<uuid>.json state file.

    Args:
        session_uuid: Unique session identifier
        project_dir: Project directory path
        tmux_session: tmux session name (if using tmux)
        session_type: Either "tmux" or "iterm"
    """
    state_file = project_dir / f".claude-monitor-{session_uuid}.json"
    state = {
        "uuid": session_uuid,
        "project_dir": str(project_dir),
        "project_name": get_project_name(project_dir),
        "started_at": datetime.now(timezone.utc).isoformat(),
        "pid": None,  # Will be updated after Claude Code launches
        "session_type": session_type,
    }

    if tmux_session:
        state["tmux_session"] = tmux_session

    state_file.write_text(json.dumps(state, indent=2))
    return state_file


def update_state_pid(state_file: Path, pid: int) -> None:
    """Update the state file with the Claude Code process PID."""
    state = json.loads(state_file.read_text())
    state["pid"] = pid
    state_file.write_text(json.dumps(state, indent=2))


def launch_claude_code_tmux(
    session_uuid: str,
    session_name: str,
    project_dir: Path,
) -> Optional[int]:
    """Launch Claude Code inside a tmux session.

    Args:
        session_uuid: Monitor session UUID
        session_name: tmux session name
        project_dir: Working directory

    Returns:
        PID of the tmux server process, or None on failure
    """
    env_str = f"CLAUDE_MONITOR_UUID={session_uuid}"

    # Check if session already exists
    if tmux_session_exists(session_name):
        print(f"tmux session '{session_name}' already exists.")
        print("Attaching to existing session...")
        # Attach to existing session
        subprocess.run(["tmux", "attach-session", "-t", session_name])
        return None

    # Create new tmux session with claude command
    # -d creates detached, then we attach
    result = subprocess.run(
        [
            "tmux", "new-session",
            "-d",  # Detached initially
            "-s", session_name,
            "-c", str(project_dir),
            f"env {env_str} claude",  # Run claude with our env var
        ],
        capture_output=True,
    )

    if result.returncode != 0:
        print(f"Failed to create tmux session: {result.stderr.decode()}")
        return None

    # Enable mouse mode for natural scrolling and text selection
    subprocess.run(
        ["tmux", "set-option", "-t", session_name, "mouse", "on"],
        capture_output=True,
    )

    # Enable automatic clipboard integration - selections copy to system clipboard
    subprocess.run(
        ["tmux", "set-option", "-t", session_name, "set-clipboard", "on"],
        capture_output=True,
    )

    # Auto-copy to macOS clipboard when mouse selection ends (global binding)
    subprocess.run(
        [
            "tmux", "bind-key", "-T", "copy-mode",
            "MouseDragEnd1Pane", "send-keys", "-X", "copy-pipe-and-cancel", "pbcopy",
        ],
        capture_output=True,
    )

    # Get the PID of the shell running in the tmux session
    pid_result = subprocess.run(
        ["tmux", "list-panes", "-t", session_name, "-F", "#{pane_pid}"],
        capture_output=True,
        text=True,
    )

    pid = None
    if pid_result.returncode == 0 and pid_result.stdout.strip():
        try:
            pid = int(pid_result.stdout.strip().split("\n")[0])
        except ValueError:
            pass

    # Attach to the session (this will block until the session ends)
    print(f"Attaching to tmux session: {session_name}")
    subprocess.run(["tmux", "attach-session", "-t", session_name])

    return pid


def cmd_start() -> None:
    """Handle the 'start' command - launch Claude Code in tmux."""
    project_dir = Path.cwd().resolve()
    session_uuid = str(uuid.uuid4())
    project_name = get_project_name(project_dir)

    # tmux is required
    if not is_tmux_available():
        print("Error: tmux is required but not found.")
        print("Install with: brew install tmux")
        sys.exit(1)

    # Create tmux session name with UUID for uniqueness
    tmux_session = f"claude-{slugify(project_name)}-{session_uuid[:8]}"
    print(f"Starting Claude Code session: {session_uuid[:8]} (tmux: {tmux_session})")

    # Create state file (minimal marker for focus functionality)
    state_file = create_state_file(
        session_uuid, project_dir,
        tmux_session=tmux_session,
        session_type="tmux",
    )
    print(f"Created state file: {state_file.name}")

    try:
        # Launch in tmux (blocks until detach/exit)
        pid = launch_claude_code_tmux(session_uuid, tmux_session, project_dir)
        if pid:
            update_state_pid(state_file, pid)
    except KeyboardInterrupt:
        pass
    finally:
        # Clean up state file when session ends
        if state_file.exists():
            state_file.unlink()
            print(f"\nSession {session_uuid[:8]} ended. State file removed.")


def cmd_help() -> None:
    """Show help message."""
    print(__doc__)
    print("Commands:")
    print("  start    Launch Claude Code in a tmux session")
    print("  help     Show this help message")
    print()
    print("Sessions run inside a named tmux session (claude-<project-slug>-<uuid8>).")
    print("This enables bidirectional control and the claude-monitor dashboard.")


def main() -> None:
    if len(sys.argv) < 2:
        cmd_help()
        sys.exit(1)

    command = sys.argv[1].lower()

    if command == "start":
        cmd_start()
    elif command in ("help", "-h", "--help"):
        cmd_help()
    else:
        print(f"Unknown command: {command}")
        cmd_help()
        sys.exit(1)


if __name__ == "__main__":
    main()
