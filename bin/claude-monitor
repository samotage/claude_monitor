#!/usr/bin/env python3
"""
claude-monitor: Wrapper script to launch Claude Code with monitoring support.

Usage:
    claude-monitor start              Launch Claude Code in a terminal session
    claude-monitor start --wezterm    Launch using WezTerm backend
    claude-monitor start --tmux       Launch using tmux backend (default)

The terminal backend is configured in config.yaml (terminal_backend setting).
Use --wezterm or --tmux flags to override the configured default.

Requirements:
    tmux: brew install tmux
    wezterm: brew install --cask wezterm
"""

import json
import re
import shutil
import subprocess
import sys
import uuid
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional

import yaml


def get_project_name(project_dir: Path) -> str:
    """Extract a reasonable project name from the directory path."""
    return project_dir.name


def slugify(name: str) -> str:
    """Convert a project name to a slug for tmux session names."""
    slug = name.lower()
    slug = re.sub(r"[\s_]+", "-", slug)
    slug = re.sub(r"[^a-z0-9-]", "", slug)
    slug = re.sub(r"-+", "-", slug)
    slug = slug.strip("-")
    return slug or "unnamed"


def load_config() -> dict:
    """Load configuration from config.yaml.

    Returns:
        Configuration dict with defaults applied.
    """
    config_path = Path(__file__).resolve().parent.parent / "config.yaml"
    default_config = {
        "terminal_backend": "tmux",
        "wezterm": {
            "workspace": "claude-monitor",
            "full_scrollback": True,
        },
    }

    if config_path.exists():
        try:
            config = yaml.safe_load(config_path.read_text()) or {}
            # Merge with defaults
            for key, value in default_config.items():
                if key not in config:
                    config[key] = value
                elif isinstance(value, dict):
                    for subkey, subvalue in value.items():
                        if subkey not in config[key]:
                            config[key][subkey] = subvalue
            return config
        except Exception:
            pass
    return default_config


def is_tmux_available() -> bool:
    """Check if tmux is installed."""
    return shutil.which("tmux") is not None


def is_wezterm_available() -> bool:
    """Check if WezTerm is installed."""
    return shutil.which("wezterm") is not None


def tmux_session_exists(session_name: str) -> bool:
    """Check if a tmux session exists."""
    result = subprocess.run(
        ["tmux", "has-session", "-t", session_name],
        capture_output=True,
    )
    return result.returncode == 0


def create_state_file(
    session_uuid: str,
    project_dir: Path,
    tmux_session: Optional[str] = None,
    session_type: str = "iterm",
) -> Path:
    """Create the .claude-monitor-<uuid>.json state file.

    Args:
        session_uuid: Unique session identifier
        project_dir: Project directory path
        tmux_session: tmux session name (if using tmux)
        session_type: Either "tmux" or "iterm"
    """
    state_file = project_dir / f".claude-monitor-{session_uuid}.json"
    state = {
        "uuid": session_uuid,
        "project_dir": str(project_dir),
        "project_name": get_project_name(project_dir),
        "started_at": datetime.now(timezone.utc).isoformat(),
        "pid": None,  # Will be updated after Claude Code launches
        "session_type": session_type,
    }

    if tmux_session:
        state["tmux_session"] = tmux_session

    state_file.write_text(json.dumps(state, indent=2))
    return state_file


def update_state_pid(state_file: Path, pid: int) -> None:
    """Update the state file with the Claude Code process PID."""
    state = json.loads(state_file.read_text())
    state["pid"] = pid
    state_file.write_text(json.dumps(state, indent=2))


def launch_claude_code_tmux(
    session_uuid: str,
    session_name: str,
    project_dir: Path,
) -> Optional[int]:
    """Launch Claude Code inside a tmux session.

    Args:
        session_uuid: Monitor session UUID
        session_name: tmux session name
        project_dir: Working directory

    Returns:
        PID of the tmux server process, or None on failure
    """
    env_str = f"CLAUDE_MONITOR_UUID={session_uuid}"

    # Check if session already exists
    if tmux_session_exists(session_name):
        print(f"tmux session '{session_name}' already exists.")
        print("Attaching to existing session...")
        # Attach to existing session
        subprocess.run(["tmux", "attach-session", "-t", session_name])
        return None

    # Create new tmux session with claude command
    # -d creates detached, then we attach
    result = subprocess.run(
        [
            "tmux",
            "new-session",
            "-d",  # Detached initially
            "-s",
            session_name,
            "-c",
            str(project_dir),
            f"env {env_str} claude",  # Run claude with our env var
        ],
        capture_output=True,
    )

    if result.returncode != 0:
        print(f"Failed to create tmux session: {result.stderr.decode()}")
        return None

    # Enable mouse mode for natural scrolling and text selection
    subprocess.run(
        ["tmux", "set-option", "-t", session_name, "mouse", "on"],
        capture_output=True,
    )

    # Enable automatic clipboard integration - selections copy to system clipboard
    subprocess.run(
        ["tmux", "set-option", "-t", session_name, "set-clipboard", "on"],
        capture_output=True,
    )

    # Auto-copy to macOS clipboard when mouse selection ends (global binding)
    subprocess.run(
        [
            "tmux",
            "bind-key",
            "-T",
            "copy-mode",
            "MouseDragEnd1Pane",
            "send-keys",
            "-X",
            "copy-pipe-and-cancel",
            "pbcopy",
        ],
        capture_output=True,
    )

    # Get the PID of the shell running in the tmux session
    pid_result = subprocess.run(
        ["tmux", "list-panes", "-t", session_name, "-F", "#{pane_pid}"],
        capture_output=True,
        text=True,
    )

    pid = None
    if pid_result.returncode == 0 and pid_result.stdout.strip():
        try:
            pid = int(pid_result.stdout.strip().split("\n")[0])
        except ValueError:
            pass

    # Attach to the session (this will block until the session ends)
    print(f"Attaching to tmux session: {session_name}")
    subprocess.run(["tmux", "attach-session", "-t", session_name])

    return pid


def wezterm_session_exists(session_name: str) -> bool:
    """Check if a WezTerm session with the given name exists.

    Uses tab_title for identification (persists even when Claude Code
    overwrites the pane title).
    """
    try:
        result = subprocess.run(
            ["wezterm", "cli", "list", "--format", "json"],
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            return False

        panes = json.loads(result.stdout) if result.stdout.strip() else []
        for pane in panes:
            tab_title = pane.get("tab_title", "")
            if tab_title == session_name:
                return True
        return False
    except (json.JSONDecodeError, subprocess.SubprocessError):
        return False


def get_wezterm_pane_id(session_name: str) -> Optional[str]:
    """Get the pane ID for a WezTerm session by tab_title."""
    try:
        result = subprocess.run(
            ["wezterm", "cli", "list", "--format", "json"],
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            return None

        panes = json.loads(result.stdout) if result.stdout.strip() else []
        for pane in panes:
            tab_title = pane.get("tab_title", "")
            if tab_title == session_name:
                return str(pane.get("pane_id"))
        return None
    except (json.JSONDecodeError, subprocess.SubprocessError):
        return None


def launch_claude_code_wezterm(
    session_uuid: str,
    session_name: str,
    project_dir: Path,
) -> Optional[str]:
    """Launch Claude Code inside a WezTerm window.

    Spawns into the current workspace (so the window is visible) and sets
    the tab title to the session name. Tab titles persist even when Claude
    Code overwrites the pane title, so the monitor can still discover sessions.

    Args:
        session_uuid: Monitor session UUID
        session_name: Session name (set as tab title for discovery)
        project_dir: Working directory

    Returns:
        Pane ID of the created session, or None on failure
    """
    env_str = f"CLAUDE_MONITOR_UUID={session_uuid}"

    # Check if session already exists (by tab_title)
    if wezterm_session_exists(session_name):
        print(f"WezTerm session '{session_name}' already exists.")
        pane_id = get_wezterm_pane_id(session_name)
        if pane_id:
            print("Focusing existing session...")
            subprocess.run(
                ["wezterm", "cli", "activate-pane", "--pane-id", pane_id],
                capture_output=True,
            )
        return pane_id

    # Create new WezTerm window with claude command
    # No --workspace: spawns into current workspace so the user can see it
    shell_cmd = f"env {env_str} claude"

    result = subprocess.run(
        [
            "wezterm",
            "cli",
            "spawn",
            "--new-window",
            "--cwd",
            str(project_dir),
            "--",
            "bash",
            "-c",
            shell_cmd,
        ],
        capture_output=True,
        text=True,
    )

    if result.returncode != 0:
        print(f"Failed to create WezTerm session: {result.stderr}")
        return None

    pane_id = result.stdout.strip()
    print(f"Created WezTerm session: {session_name} (pane: {pane_id})")

    # Set tab title for persistent identification
    # Tab titles survive Claude Code overwriting the pane title
    if pane_id:
        subprocess.run(
            ["wezterm", "cli", "set-tab-title", "--pane-id", pane_id, session_name],
            capture_output=True,
        )

    # Focus the new window
    if pane_id:
        subprocess.run(
            ["wezterm", "cli", "activate-pane", "--pane-id", pane_id],
            capture_output=True,
        )

    return pane_id


def cmd_start(backend_override: Optional[str] = None) -> None:
    """Handle the 'start' command - launch Claude Code in a terminal session.

    Args:
        backend_override: Override configured backend ("tmux" or "wezterm")
    """
    project_dir = Path.cwd().resolve()
    session_uuid = str(uuid.uuid4())
    project_name = get_project_name(project_dir)

    # Load config to determine backend
    config = load_config()
    backend = backend_override or config.get("terminal_backend", "tmux")

    # Session name pattern: claude-<slug>-<uuid8>
    session_name = f"claude-{slugify(project_name)}-{session_uuid[:8]}"

    if backend == "wezterm":
        # WezTerm backend
        if not is_wezterm_available():
            print("Error: WezTerm is required but not found.")
            print("Install with: brew install --cask wezterm")
            sys.exit(1)

        print(f"Starting Claude Code session: {session_uuid[:8]} (wezterm: {session_name})")

        # Create state file
        state_file = create_state_file(
            session_uuid,
            project_dir,
            tmux_session=session_name,  # Use same field for session name
            session_type="wezterm",
        )
        print(f"Created state file: {state_file.name}")

        try:
            # Launch in WezTerm (non-blocking - WezTerm manages its own window)
            pane_id = launch_claude_code_wezterm(session_uuid, session_name, project_dir)
            if pane_id:
                # Update state file with pane_id (can be used for focus)
                state = json.loads(state_file.read_text())
                state["wezterm_pane_id"] = pane_id
                state_file.write_text(json.dumps(state, indent=2))

            # WezTerm sessions run in their own window, so we don't block here
            print(f"\nSession {session_uuid[:8]} started in WezTerm.")
            print("The session runs in a separate WezTerm window.")
            print("State file will be cleaned up when the session ends.")
            print("\nTip: Run 'claude-monitor setup-wezterm' for faster turn detection.")

        except KeyboardInterrupt:
            pass

    else:
        # tmux backend (default)
        if not is_tmux_available():
            print("Error: tmux is required but not found.")
            print("Install with: brew install tmux")
            sys.exit(1)

        print(f"Starting Claude Code session: {session_uuid[:8]} (tmux: {session_name})")

        # Create state file
        state_file = create_state_file(
            session_uuid,
            project_dir,
            tmux_session=session_name,
            session_type="tmux",
        )
        print(f"Created state file: {state_file.name}")

        try:
            # Launch in tmux (blocks until detach/exit)
            pid = launch_claude_code_tmux(session_uuid, session_name, project_dir)
            if pid:
                update_state_pid(state_file, pid)
        except KeyboardInterrupt:
            pass
        finally:
            # Clean up state file when session ends
            if state_file.exists():
                state_file.unlink()
                print(f"\nSession {session_uuid[:8]} ended. State file removed.")


def cmd_setup_wezterm() -> None:
    """Print setup instructions for WezTerm Enter-key integration."""
    # Use new src/ path - prefer it if exists, fall back to lib/
    hooks_file = Path(__file__).resolve().parent.parent / "src" / "backends" / "wezterm_hooks.lua"
    if not hooks_file.exists():
        # Fall back to legacy location for compatibility
        hooks_file = (
            Path(__file__).resolve().parent.parent / "lib" / "backends" / "wezterm_hooks.lua"
        )

    print("WezTerm Enter-Key Integration Setup")
    print("=" * 40)
    print()
    print("This adds an Enter key hook to WezTerm that notifies the monitor")
    print("when you press Enter in a Claude session, reducing detection latency.")
    print()
    print("Add this to your ~/.wezterm.lua (before 'return config'):")
    print()
    print(f"  local claude_hooks = dofile('{hooks_file}')")
    print("  claude_hooks.apply(config)")
    print()
    print("To use a custom port (default 5050):")
    print()
    print(f"  local claude_hooks = dofile('{hooks_file}')")
    print("  claude_hooks.apply(config, { port = 5050 })")
    print()
    print("Notes:")
    print("  - Only fires for panes with titles starting 'claude-'")
    print("  - Shift+Enter (newline) is unaffected")
    print("  - Fails silently if the monitor server is not running")
    print("  - Requires curl (standard on macOS)")
    print()
    print(f"Hook file: {hooks_file}")


def cmd_help() -> None:
    """Show help message."""
    print(__doc__)
    print("Commands:")
    print("  start              Launch Claude Code in a terminal session")
    print("  start --tmux       Launch using tmux backend (default)")
    print("  start --wezterm    Launch using WezTerm backend")
    print("  setup-wezterm      Show WezTerm Enter-key integration setup")
    print("  help               Show this help message")
    print()
    print("Sessions run inside a named session (claude-<project-slug>-<uuid8>).")
    print("This enables bidirectional control and the claude-monitor dashboard.")
    print()
    print("Configuration:")
    print("  Set terminal_backend in config.yaml to change the default backend.")
    print("  Use --tmux or --wezterm flags to override the configured default.")


def main() -> None:
    if len(sys.argv) < 2:
        cmd_help()
        sys.exit(1)

    command = sys.argv[1].lower()

    if command == "start":
        # Parse optional backend flags
        backend_override = None
        if "--wezterm" in sys.argv:
            backend_override = "wezterm"
        elif "--tmux" in sys.argv:
            backend_override = "tmux"
        cmd_start(backend_override)
    elif command == "setup-wezterm":
        cmd_setup_wezterm()
    elif command in ("help", "-h", "--help"):
        cmd_help()
    else:
        print(f"Unknown command: {command}")
        cmd_help()
        sys.exit(1)


if __name__ == "__main__":
    main()
